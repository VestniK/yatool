# prepare.py

## PrepareAllNodesTask
Данная задача производит первоначальное создание очереди задач для локального исполнителя (раннера). В ней выполняется обход графа, начиная от результирующих узлов, и далее по их зависимостям (deps), пока все требующиеся задачи не будут созданы.
Вкратце алгоритм обхода устроен следующим образом:
- вначале из списка результатов сборки создаём список узлов для последующего рассмотрения;
- в цикле проверяем каждый узел из списка выше:
    - если узел найден в одном из кэшей (локальном или распределённом), то создаём задачу на извлечение артефакта из соответствующего кэша;
    - если узел не найден ни в одном из кэшей, когда включен режим yt_store_exclusive, то работа задачи аварийно завершается
    - если узел не найден ни в одном из кэшей, то "шедулим" задачу на исполнение узла (об этом отдельно), а в список узлов на рассмотрение добавляем зависимости этого узла;
- продолжаем цикл до тех пор, пока не останется узлов для рассмотрения.

Для обхода графа используется экземпляр класса [Topo](https://a.yandex-team.ru/arcadia/devtools/ya/yalibrary/runner/topo.py?rev=r14528918#L51). Этот класс отслеживает зависимости узлов и умеет однократно исполнять переданную пользовательскую функцию при переходе всех зависимостей узла в исполненное состояние. Хотя под капотом класс использует [DisjointSet](https://a.yandex-team.ru/arcadia/devtools/ya/yalibrary/runner/topo.py?rev=r14528918#L5) (см. [Wikipedia](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)), в рамках PrepareAllNodesTask функция объединения узлов не используется, то есть в каждой группе (set) содержится ровно один узел. Ниже работа Topo будет описана упрощённо и без учёта объединения узлов.

### Topo

Узел в `Topo` может находиться в трёх состояниях: начальном, scheduled и completed. После добавления узла в `Topo` (метод `add_node`) узел находится в начальном состоянии. Отдельным методом `add_deps` можно привязать к узлу другие узлы, от которых он зависит. Узлы зависимостей должны быть добавлены в `Topo` через  `add_node` до вызова `add_deps`.

Метод `schedule_node` переводит узел в состояние scheduled и к узлу прикрепляется передаваемая в параметре `when_ready` функция-callback. Если все зависимости этого узла находятся в состоянии completed, то callback немедленно исполняется, если нет, то сохраняется на будущее.

Метод `notify_dependants` переводит переданный в параметре узел в состояние completed и для всех узлов, которые зависят от переданного, уменьшает количество зависимостей на единицу. Если обнаруживается что зависимый узел находится в состоянии scheduled и количество зависимостей у него стало равным нулю, то для него вызывается callback, который был ранее передан при вызове `schedule_node`.

Таким образом, в общих чертах цепочка выглядит так:
1. узел в начальном состоянии и для него добавлены зависимости;
2. узел переводится в состояние scheduled вызовом `schedule_node`;
3. все зависимости узла в какой-то момент успешно исполняются и для узла вызывается callback `when_ready`;
4. callback делает какую-то полезную работу непосредственно или делегирует её в отдельный поток;
5. после окончания полезной работы для узла вызывается `notify_dependants`, и узел переводится в состояние completed, что может привести к исполнению пункта 3 для какого другого узла.

Методы класса `Topo` защищены блокировкой и безопасны с точки зрения многопоточного использования.

### Детали алгоритма обработки узлов
Если узел найден в одном из кэшей, то, как уже написано в кратком изложении выше, мы добавляем в раннер задачу на извлечение результата из кэша. Далее мы вызываем метод `Topo.schedule_node`, где в качестве `when_ready` выступает функция, вызывающая метод `notify_dependants`. Так как данный узел не зависит от других узлов, то он сразу же переходит в состояние completed и вызывает `when_ready`. (Формально, код добавления задачи в раннер и есть "полезная работа", поэтому его можно было бы разместить в функции `when_ready`, но что есть, то есть).

Если узла в кэше нет, то для получения результата надо исполнить команды этого узла, но мы не можем сразу отправить в раннер задачу на исполнение, так как не созданы задачи для получения зависимостей, поэтому помещаем эти зависимости в `Topo` и добавляем их в список для рассмотрения. Потом делаем для узла `schedule_node`, где в качестве `when_ready` передаём функцию `add_run_node`, в которой добавляем задачу `run_node` в раннер и уведомляем зависимые узлы.

В итоге, обходим дерево зависимостей, либо до узла, у которого нет других зависимостей, либо его результат есть в сборочном кэше. В алгоритме обхода предприняты меры, чтобы каждый узел рассматривался не более одного раза.
