Это часть библиотеки EDL (Event Driven Loader)

### loaders.cpp, loaders.h

Центром всего является такая сущность, как лоадер. Все лоадеры наследуются от `TBaseLoader` и предоставляют унифицированный интерфейс для получения событий из системы поставки данных (во многом напоминает `NJson::TJsonCallbacks`). Каждый тип данных имеет соответствующий ему лоадер, который "знает" как его заполнять. `TBaseLoader` по-умолчанию отвергает все типы данных (бросает исключение `TLoaderError`). Это сделано, чтобы наследники могли переопределить методы только под те виды данных, которые в состоянии обработать, и не заботиться о неожиданных данных. Большинство лоадеров наследуются от `TLoaderForRef`. Это шаблонный класс, который только и умеет, что сохранять ссылку на переданный объект и давать доступ к этой ссылке классам-наследникам. Несмотря на простоту, он избавляет от большого количества однотипного кода.
Объекты лоадера создаются и уничтожаются на каждый элементарный загружаемый объект. Поэтому они должны быть максимально лёгкими. В большинстве случае они имеют размер одной ссылки. Для получения лоадера для какого либо типа служит шаблонная функция `GetLoader()`:
```
    template <class T>
    class TLoader;

    template <class T>
    inline TLoaderPtr GetLoader(T& val) {
        return MakeHolder<TLoader<T>>(val);
    }
```
Использован именно `THolder`, потому что он следит за временем жизни объекта, позволяет делать виртуальные вызовы и не тратит ресурсы на хранение и подсчёт ссылок.
Чтобы сделать лоадер для своего типа данных, нужно сделать для него специализацию шаблона `TLoader`. Понятно, что эта специализация так или иначе должна наследоваться от `TBaseLoader` или, что удобнее, от `TLoaderForRef`.
Классы, которые предполагается заполнять с помощью EDL, обязательно должны иметь конструктор по умолчанию, так как объект сначала создаётся, а потом только изменяется по мере поступления данных.
В loaders.h уже есть специализации (как частичные так и полные) под часто используемые типы данных.
Из особенные типов можно упомянуть `NYa::NEdl::TBlackHole`. Его лоадер полностью игнорирует все поступающие в него данные, в том числе вложенные. Может быть полезно, если нужно проигнорировать какое-нибудь легаси:
```
struct TData {
  ...
  ((TBlackHole) Obsoleted),  # Объяснение такого странного синтаксиса ниже.
  ...
}
```
**Важно**. Null-значения поддерживает только специализация лоадера для `NJson::TJsonValue`. Остальные лоадеры (даже для указателей) бросают исключения.

### members.cpp, members.h

##### `Y_EDL_MEMBERS`
В C++ нет рефлексии, а очень хочется, поэтому по мотивам одного рецепта со StackOverflow был написан макрос `Y_EDL_MEMBERS`, который создаёт что-то типа RTTI для бедных (назовём EDL-RTTI). Под этот EDL-RTTI написаны специализации лоадера и экспортера, которые сами добывают из RTTI поля, их имена и значения. Использование макроса выглядит так:
```
struct TData(
  Y_EDL_MEMBERS(
    ((int) Field1),
    ((String) Field2, "field-2"),
    ((TVector<TString>) Field3, "", NYa::NEdl::EMemberExportPolicy::ALWAYS)
  )
);
```
В скобочках (чтобы переваривать что-то типа `unsigned long long`) указывается тип поля, после скобочек через пробел - имя поля. По умолчанию "внешнее" имя поля (ключ словаря в json или Python) - это snake_case от имени поля. Имя можно переопределить, как сделано, например, выше для поля `Field2`. Можно указать пустое имя (см. `Field3`), тогда тоже будет использовано имя по умолчанию (такой финт нужен, чтобы удобнее использовать export policy). Про Export policy написано в пункте про экспорт

#### `Y_EDL_DEFAULT_MEMBER`
Так как плюсовое представление сборочного графа - лишь промежуточный этап между ymake и обширной питоновой частью ya-bin, то в плюсах нет необходимости типизировать всё до последнего байта. Часть данных нужно просто бережно сохранить и передать дальше. Другими словами, все незнакомые ключи и их данные при загрузке нужно куда-нибудь положить, а при экспорте отдать без изменения. Для этого можно использовать макрос `Y_EDL_DEFAULT_MEMBER`. Лоадер для поля, которое определено в этом макросе, будет получать все незнакомые поля. Этому полю можно сделать тип `THash<TString, NJson::TJsonValue`, чтобы всё сохранить. Или `TBlackHole`, чтобы, наоборот, всё  выкинуть. Экспорт поля из этого макроса имеет особенности, которые подробнее описаны в пункте про export_helpers.
Кроме свалки всего неизвестного `Y_EDL_DEFAULT_MEMBER` можно использовать для случаев, когда у структуры есть постоянная и переменная часть. Тогда постоянную часть можно описать в `Y_EDL_MEMBERS`, а переменную определить через поле типа `std::variant`, которое положить в `Y_EDL_DEFAULT_MEMBER`.

### export_helpers.cpp, export_helpers.h
Вообще говоря, экспорту нечего делать в Event Driven **Loader**, но уж больно заманчиво переиспользовать EDL-RTTI и для экспорта тоже. В export_helpers лежат вспомогательные шаблоны, к которым конкретный экспортер (далее буду называть его просто экспортер) может обращаться, если не знает, что делать с тем или иным типом. Предполагается, что специализации экспортера имеют приоритет над описанными в export_helpers, например, даже если класс имеет EDL-RTTI, то экспортер может решить его экспортировать самостоятельно, и никто ему этого не запретит. В коде экспортера это может выглядеть как набор специализаций шаблонов под различные типы и обобщённый шаблон, который обращается к export helpers за помощью. Основа export helpers - это два шаблона:
```
    template <class E, class T>
    struct TExportHelper {
        static void Export(E&& e, const T& val);
    };

    template <class E, class T>
    inline void Export(E&& e, const T& val) {
        return TExportHelper<E, T>::Export(std::forward<E>(e), val);
    }
```
Чтобы использовать шаблоны из export_helpers, в экспортере нужно создать специальный класс (передаётся параметром `E&& e`), который будет получать события от этих шаблонов и как-то реагировать на них. В отличие от лоадеров, здесь нет необходимости в общем базовом классе, так как тип класса передаётся параметром шаблона. Этот класс должен иметь следующие методы:
```
// Для экспорта словарей или классов с EDL-RTTI
void OpenMap();
void CloseMap();
template <class K, class V>
void AddMapItem(const K& key, const V& value);

// Для экспорта массивов
template<class Iter>
void ExportRange(Iter begin, Iter end);

// Для экспорта null
void ExportNullValue();

// Обычно используется при разыменовании TMaybe, std::variant и умных указателей, так как простые значения экспортер должен поддерживать напрямую
template<class T>
void ExportValue(const T& value);

// Экспорт поля из макроса Y_EDL_DEFAULT_MEMBER.
template <class T>
void ExportInnerValue(const T& value);
```
Цепочка вызовов при использовании хелпера может выглядеть примерно так:
```
E = TPyObjectExporter

// Для указателя на тип T:
ToPyObject(T*) -> Export(E, T*) -> TExportHelper::Export(E, T*) -> E::ExportValue(T) -> ToPyObject(T)

// Для структуры или словаря типа T:
ToPyObject(T) -> Export(E, T) -> TExportHelper::Export(E, T) -> E::OpenMap() ->
  (E::AddMapItem(K1, V1) -> ToPyObject(K1), ToPyObject(V1) -> ...) ->
  (E::AddMapItem(K2, V2) -> ... ) ->
  E::CloseMap()

// Для массива элементов типа T
ToPyObject(TVector<T>) -> Export(E, TVector<T>) -> TExportHelper::Export(E, TVector<T>) ->
  E::ExportRange(TVector<T>::const_iterator, TVector<T>::const_iterator) -> (ToPyObject(T), ...)
```

#### Export policy
Export policy может иметь два значения: `NOT_EMPTY` и `ALWAYS`. Первое используется по умолчанию, и в этом случае поле, которое имеет "пустое" значение (пустые контейнеры и строки, нулевые умные указатели, нулевые значения чисел и так далее, в общем, всё что может использоваться в `if(...)` или `if(!std::empty(...))` игнорируется и не попадает в экспортируемое представление. Если указан `ALWAYS`, то для контейнеров при экспорте будут созданы, соответственно, пустые словари или массивы, для указателей - `null` (json) или `None` (python), для чисел и строк - их текущие значения. Можно переопределить понятие "пустой" для своего типа, добавив специализацию класса `NYa::NEdl::TEmptyChecker` (см export_helpers.h)
Вся это логика c политикой экспорта сделана потому, что в json и Python какие-то данные могут быть опциональными. Если отсутствие поля и его "пустое" значение тождественны, например, пустая строка или массив и их отсутствие для потребителя равнозначны, то в С++ можно напрямую использовать соответствующую структуру и оставить дефолтную (`NOT_EMPTY`) политику экспорта. Если нужно различать отсутствие значения и нулевое значение, то для поля можно использовать `TMaybe` или умный указатель (выбор между ними зависит от размера поля и частотности его непустого состояния). При экспорте эти типы (`TMaybe` и умные указатели) являются "прозрачными", то есть на выход попадёт значение только того типа, на который они ссылаются. Для пометки "прозрачности" типов служит шаблонная константа `constexpr bool NYa::NEdl::IsOptional`.

#### Y_EDL_DEFAULT_MEMBER и ExportInnerValue
Когда мы в классе определяем поле `Y_EDL_DEFAULT_MEMBER`, то мы подразумеваем, что все явно не описанные поля будут сохранены в это специальное поле. При экспорте содержимое полей этого поля мы должны как бы вложить в родительскую структуру. Пример:
```
struct TData {
  Y_EDL_MEMBERS(
    ((int) Field1)
  )
  Y_EDL_DEFAULT_MEMBER((THash<TString, NJson::TJsonValue>) Tundra)
};
```
Если на вход подать
```
{
  "field1": 13,
  "field_n": 14
}
```
значение 13 попадёт в `Field1`, а 14 - станет частью словаря `Tundra`: `{"field_n": 14}`. При экспорте мы ожидаем, что `field_n` опять станет полем в `TData`, а не словаря `Tundra`:
```
// Вот такого мы не хотим!!!
{
  "field1": 13,
  "tundra": {
    "field_n": 14
  }
}
```
Чтобы экспортер понимал, что `AddMapItem(const& K key, const V& value)`, которые будут вызываться из экспортера для `Tundra`, нужно делегировать в `AddMapItem` для `TData`, сделан отдельный метод `ExportInnerValue`. Это уже забота экспортера, как использовать эту информацию. Скорее всего это будет небольшой набор отдельных специализаций для делегирующих экспортеров.
